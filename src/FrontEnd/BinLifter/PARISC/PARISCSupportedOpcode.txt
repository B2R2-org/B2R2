/// To cause a break instruction trap for debugging purposes.
BREAK
/// To enforce program order of instruction execution.
SYNC
/// To enforce DMA completion order.
SYNCDMA
/// To restore processor state
RFI
/// To selectively set bits in the system mask to 1.
SSM
/// To selectively reset bits in the system mask to 0.
RSM
/// To set PSW system mask bits to a value from a register.
MTSM
/// To calculate the space register number referenced by an implicit pointer
LDSID
/// To move a value from a general register to a space register.
MTSP
/// To move a value to a general register from a space register.
MFSP
/// To move a value from a general register to a control register.
MTCTL
/// To take the oneâ€™s complement of a value from a general register.
MTSARCM
/// To move the current instruction address to a general register.
MFIA
/// To move a value to a general register from a control register.
MFCTL
/// To provide implementation-dependent operations for system initialization
DIAG
/// To add an entry to the instruction TLB.
IITLBT
/// To invalidate an instruction TLB entry.
PITLB
/// To invalidate an instruction TLB entry without matching the address portion.
PITLBE
/// To invalidate an instruction cache line.
FIC
/// To provide for flushing the entire instruction or combined cache
FICE
/// To add an entry to the data TLB.
IDTLBT
/// To invalidate a data TLB entry.
PDTLB
/// To invalidate a data TLB entry without matching the address portion.
PDTLBE
/// To invalidate a data cache line and write it back to memory if it is dirty.
FDC
/// To provide for flushing the entire data or combined cache
FDCE
/// To invalidate a data cache line.
PDC
/// To determine whether read or write access to a given address is allowed.
PROBE
/// To determine whether read or write access to a given address is allowed.
PROBEI
/// To determine the absolute address of a mapped virtual page.
LPA
/// To determine the coherence index corresponding to a virtual address.
LCI
/// To do 64-bit integer addition and conditionally
ADD
/// To provide a primitive operation for multiplication.
SHLADD
/// To do 64-bit integer subtraction, and conditionally
SUB
/// To provide the primitive operation for integer division.
DS
/// To do a 64-bit bitwise AND with complement.
ANDCM
/// To do a 64-bit, bitwise AND.
AND
/// To do a 64-bit, bitwise inclusive OR.
OR
/// To do a 64-bit, bitwise exclusive OR.
XOR
/// To individually compare corresponding sub-units
UXOR
/// To compare two registers, set a register to 0, and conditionally
CMPCLR
/// To individually compare corresponding sub-units of a doubleword
UADDCM
/// To separately correct the 16 BCD digits of the result
DCOR
/// To add multiple halfwords in parallel with optional saturation.
HADD
/// To subtract multiple halfwords in parallel with optional saturation.
HSUB
/// To average multiple halfwords in parallel.
HAVG
/// To perform multiple halfword shift left and add
HSHLADD
/// To perform multiple halfword shift right and add
HSHRADD
/// To load a byte into a general register.
LDB
/// To load a halfword into a general register.
LDH
/// To load a word into a general register.
LDW
/// To load a doubleword into a general register.
LDD
/// To load a doubleword into a general register from an absolute address.
LDDA
/// To read and lock a doubleword semaphore in main memory.
LDCD
/// To load a word into a general register from an absolute address.
LDWA
/// To read and lock a word semaphore in main memory.
LDCW
/// To store a byte from a general register.
STB
/// To store a halfword from a general register.
STH
/// To store a word from a general register.
STW
/// To store a doubleword from a general register.
STD
/// To implement the beginning, middle, and ending cases
STBY
/// To implement the beginning, middle, and ending cases
STDBY
/// To store a word from a general register to an absolute address.
STWA
/// To store a doubleword from a general register to an absolute address.
STDA
/// To load a word into a floating-point coprocessor register.
FLDW
/// To store a word from a floating-point coprocessor register.
FSTW
/// To load a doubleword into a floating-point coprocessor register.
FLDD
/// To store a doubleword from a floating-point coprocessor register.
FSTD
/// To add an immediate value to a register and conditionally
ADDI
/// To subtract a register from an immediate value and conditionally
SUBI
/// To shift a pair of registers by a fixed or variable amount and conditionally
SHRPD
/// To shift the rightmost 32 bits of a pair of registers
SHRPW
/// To extract any 64-bit or shorter field from a fixed or variable position
EXTRD
/// To extract any 32-bit or shorter field from a fixed or variable position
EXTRW
/// To deposit a value into a register at a fixed or variable position
DEPD
/// To deposit an immediate value into a register
DEPDI
/// To deposit a value into the rightmost 32 bits of a register
DEPW
/// To deposit an immediate value into the rightmost 32 bits of a register
DEPWI
/// To select any combination of four halfwords from a source register
PERMH
/// To perform multiple parallel halfword shift left operations.
HSHL
/// To perform multiple parallel halfword
HSHR
/// To combine two words from two source registers
MIXW
/// To combine four halfwords from two source registers
MIXH
/// To do IA-relative branches with optional privilege level change
B
/// To do IA-relative branches with a dynamic displacement
BLR
/// To do base-relative branches with a dynamic displacement
BV
/// To do procedure calls, branches and returns to another space.
BE
/// To do base-relative branches and procedure calls to another space.
BVE
/// To add two values and perform an IA-relative branch conditionally
ADDB
/// To add two values and perform an IA-relative branch conditionally
ADDIB
/// To perform an IA-relative branch conditionally
BB
/// To compare two values and perform an IA-relative branch conditionally
CMPB
/// To compare two values and perform an IA-relative branch conditionally
CMPIB
/// To copy one register to another and perform an IA-relative branch
MOVB
/// To copy an immediate value into a register
MOVIB
/// To compare an immediate value with the contents of a register
CMPICLR
/// To load a word into a coprocessor register.
CLDW
/// To load a doubleword into a coprocessor register.
CLDD
/// To store a word from a coprocessor register.
CSTW
/// To store a doubleword from a coprocessor register.
CSTD
/// To invoke a coprocessor unit operation.
COPR
/// To invoke a special function unit operation.
SPOP0
/// To copy a special function unit register or a result to a general register.
SPOP1
/// To perform a parameterized special function unit operation.
SPOP2
/// To perform a parameterized special function unit operation.
SPOP3
/// To validate fields in the Status Register
FID
/// To copy a floating-point value to another floating-point register.
FCPY
/// To perform a floating-point absolute value.
FABS
/// To perform a floating-point square root.
FSQRT
/// To round a floating-point value to an integral value.
FRND
/// To negate a floating-point value.
FNEG
/// To negate a floating-point absolute value.
FNEGABS
/// To change the value in a floating-point register
FCNV
/// To perform a floating-point comparison.
FCMP
/// To test the results of one or more earlier comparisons.
FTEST
/// To perform a floating-point addition.
FADD
/// To perform a floating-point subtraction.
FSUB
/// To perform a floating-point multiply.
FMPY
/// To perform a floating-point division.
FDIV
/// To perform a floating-point multiply and fused add.
FMPYFADD
/// To perform a floating-point multiply, negate, and fused add.
FMPYNFADD
/// To disable the implementation-dependent performance monitor coprocessor
PMDIS
/// To enable the implementation-dependent performance monitor coprocessor.
PMENB
/// To load an offset into a general register.
LDO
/// To load the upper portion of a 32-bit immediate value
LDIL
/// To add the upper portion of a 32-bit immediate value to a general register.
ADDIL
/// To push a value from a GR onto the branch target stack.
PUSHBTS
/// To push the currently nominated address onto the branch target stack.
PUSHNOM
/// To clear the branch target stack.
CLRBTS
/// To perform a floating-point multiply and a floating-point add.
FMPYADD
/// To perform a floating-point multiply and a floating-point subtract.
FMPYSUB
/// To perform unsigned fixed-point multiplication.
XMPYU